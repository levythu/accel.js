<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>index.md</title></head>
<body><h2>Wonderful Features</h2>
<h3>One-step Wrapper to Parallelize Function</h3>
<p>Simply by wrapping one function with <code>$()</code>, you can get one distributed version and invoke it on workers. Note that in wrapped functions, you can only refer to <code>$</code> (synchronized environment) and <code>accel</code> (package itself).</p>
<h3>Easy to Go Distributed</h3>
<p>All you need to do to parallelize your Node.js application to multiple machines is modify your launching command, <em>e.g.</em>, from <code>acceljs bar.js</code> to <code>acceljs -l 4 -r m1:15618 4 bar.js</code>. (For detail refer to <code>acceljs --help</code>)</p>
<h3>Environment Synchronization</h3>
<p>Accel.js performs smart (delta sync) and transparent environment synchronization to help you transfer all data you want to workers. Since it is delta synchronization, you won&#39;t pay for extra communication costs once transferred.</p>
<pre><code class='language-javascript' lang='javascript'>
const accel=require(&quot;accel&quot;);
const $=accel();

$.alpha=0.6;
$.mixNumber=(c1, c2) =&gt; $.alpha*c1+(1-$.alpha)*c2;
$(function foo(n) {
    // you can use $.mixNumber and $.alpha here
});
</code></pre>
<h3>Asynchronous Function on Worker</h3>
<p>Although Accel.js by default treats one function as completed in return, you can explicitly assign an asynchronous function to worker and it will not be marked completed until callback is invoked.</p>
<pre><code class='language-javascript' lang='javascript'>
function bar(time, callback) {
    setTimeout(() =&gt; callback(&quot;Finishes&quot;), time);
}
$(bar, &quot;async&quot;)(1000, (res) =&gt; {
    // will get here after 1000ms
});
</code></pre>
<h3>Universal Dependency</h3>
<p>When you want to require a dependency for worker, you don&#39;t have to do it once in every worker code. Instead, take our universal dependency and use it everywhere.</p>
<pre><code class='language-javascript' lang='javascript'>
$.os=accel.require(&quot;os&quot;);    // introduce an universal dependency
function printOS() {
    return $.os.platform();  
}
console.log(printOS);    // you can use it on master
$(printOS)((res) =&gt; console.log(res));  // or use it on worker
</code></pre>
<h3>MPI Support</h3>
<p>Accel.js also have brilliant support for MPI jobs, where you assign long running jobs for each node (instead of assigned by job queues) and each job communicate with each other.</p>
<pre><code class='language-javascript' lang='javascript'>
$.ch1=new accel.Channel();  // a multi-producer-multi-consumer channel
function MPIJob(callback) {
    var nodeId=accel.id;
    accel.Recv((msg, fromNode) =&gt; {  // receive a message from pre-defined channel
        // ...
    });
    $.ch1.Send(someMessage);  // or send one message to self-defined broadcast channel
}
$(MPIJob, &quot;async&quot;).toAll()(() =&gt; {
    // since MPI job do not complete, the callback will never get invoked
});
</code></pre>
<h2>Comparison</h2>
<table>
<thead>
<tr><th></th><th>Accel.js</th><th><a href='https://github.com/parallel-js/parallel.js'>Parallel.js</a> (Rockstar with 2K+ stars)</th><th>Cluster (Node.js original)</th></tr></thead>
<tbody><tr><td>Computational Resources</td><td><strong>Local Cores &amp; Cluster Cores</strong></td><td>Local Cores</td><td>Local Cores</td></tr><tr><td>Lines of Code for Similar Tasks (Mandelbrot, ~20 for serial)</td><td><strong>~40</strong></td><td>~60</td><td>~80</td></tr><tr><td>Load Balancing Assignment</td><td><strong>YES</strong></td><td><strong>YES</strong></td><td>NO</td></tr><tr><td>Manual Assignment</td><td><strong>YES</strong></td><td>NO</td><td><strong>YES</strong></td></tr><tr><td>Asynchronous Job Support</td><td><strong>YES</strong></td><td>NO</td><td><strong>YES</strong></td></tr><tr><td>Overhead per Job</td><td><strong>LOW</strong></td><td>HIGH</td><td><strong>LOW</strong></td></tr><tr><td>Data Synchronization Mechanism</td><td><strong>Transparent sync environment</strong></td><td>One string only</td><td>One string only</td></tr><tr><td>MPI Support</td><td><strong>YES</strong></td><td>NO</td><td><strong>YES</strong></td></tr><tr><td>Data-Parallel Support</td><td>On the way!</td><td><strong>YES</strong></td><td>NO</td></tr></tbody>
</table>
<h3>Performance</h3>
<p><img src='./experiment/mandelbrot/mandelbrot.png' alt='' /></p>
<p><em>All experiments are conducted on 4-core machines. Task to be done is rendering 26k x 4k mandelbrot graph.</em></p>
</body>
</html>